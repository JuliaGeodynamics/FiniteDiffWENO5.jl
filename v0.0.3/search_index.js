var documenterSearchIndex = {"docs":
[{"location":"GettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"There are currently two exported functions in FiniteDiffWENO5.jl: WENOScheme() and WENO_step!(). The user must define the grid and the initial conditions themselves.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"WENOScheme() is used to create a WENO scheme structure containing all the necessary information for the WENO method, while WENO_step!() performs one step of the time integration using the WENO-Z method and a 3rd-order Runge-Kutta method. Refer to the docstrings to see the available options for each function.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Here is a simple example of how to use FiniteDiffWENO5.jl to solve the 1D advection equation using the conservative form on a staggered grid. For more examples, please refer to the folder examples in the repository or the tests in the test folder.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using FiniteDiffWENO5\n\nnx = 400\n\nx_min = -1.0\nx_max = 1.0\nLx = x_max - x_min\n\nx = range(x_min, stop = x_max, length = nx)\n\n# Courant number\nCFL = 0.4\nperiod = 4\n\n# Parameters for Shu test\nz = -0.7\nδ = 0.005\nβ = log(2) / (36 * δ^2)\na = 0.5\nα = 10\n\n# Functions\nG(x, β, z) = exp.(-β .* (x .- z) .^ 2)\nF(x, α, a) = sqrt.(max.(1 .- α^2 .* (x .- a) .^ 2, 0.0))\n\n# Grid x assumed defined\nu0_vec = zeros(length(x))\n\n# Gaussian-like smooth bump at x in [-0.8, -0.6]\nidx = (x .>= -0.8) .& (x .<= -0.6)\nu0_vec[idx] .= (1 / 6) .* (G(x[idx], β, z - δ) .+ 4 .* G(x[idx], β, z) .+ G(x[idx], β, z + δ))\n\n# Heaviside step at x in [-0.4, -0.2]\nidx = (x .>= -0.4) .& (x .<= -0.2)\nu0_vec[idx] .= 1.0\n\n# Piecewise linear ramp at x in [0, 0.2]\n# Triangular spike at x=0.1, base width 0.2\nidx = abs.(x .- 0.1) .<= 0.1\nu0_vec[idx] .= 1 .- 10 .* abs.(x[idx] .- 0.1)\n\n# Elliptic/smooth bell at x in [0.4, 0.6]\nidx = (x .>= 0.4) .& (x .<= 0.6)\nu0_vec[idx] .= (1 / 6) .* (F(x[idx], α, a - δ) .+ 4 .* F(x[idx], α, a) .+ F(x[idx], α, a + δ))\n\n\nu = copy(u0_vec)\n\n# fix here boundary to periodic when equal to 2\n# staggering = true means that the advection velocity is defined on the sides of the cells and should be of size nx+1 compared to the scalar field u.\n# Multithreading to false means that the computations will be done on a single thread.\n# Set to true to enable multithreading if the Julia session was started with multiple threads (e.g. `julia -t 4`).\nweno = WENOScheme(u; boundary = (2, 2), stag = true, multithreading = false)\n\n# advection velocity with size nx+1 for staggered grid (here constant)\na = (; x = ones(nx + 1))\n\n# grid size\nΔx = x[2] - x[1]\nΔt = CFL * Δx^(5 / 3)\n\ntmax = period * (Lx + Δx) / maximum(abs.(a.x))\n\nt = 0\n\nwhile t < tmax\n    # take as input the scalar field u, the advection velocity a as a NamedTuple,\n    # the WENO scheme struct weno, the time step Δt and the grid size Δx\n    WENO_step!(u, a, weno, Δt, Δx)\n\n    t += Δt\n\n    if t + Δt > tmax\n        Δt = tmax - t\n    end\nend\n\nf = Figure(size = (800, 600), dpi = 400)\nax = Axis(f[1, 1], title = \"1D linear advection after $period periods\", xlabel = \"x\", ylabel = \"u\")\nlines!(ax, x, u0_vec, label = \"Exact\", linestyle = :dash, color = :red)\nscatter!(ax, x, u, label = \"WENO5\")\nxlims!(ax, x_min, x_max)\naxislegend(ax)\ndisplay(f)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"which outputs:","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: 1D advection)","category":"page"},{"location":"background/#background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The weighted essentially non-oscillatory (WENO) schemes form a class of high-order accurate numerical methods for solving hyperbolic partial differential equations (PDEs). They are particularly effective at resolving sharp gradients and discontinuities without introducing spurious oscillations. The WENO schemes achieve this by constructing nonlinear convex combinations of lower-order candidate polynomials, where the weights are determined by the local smoothness of the solution. This approach allows the method to retain high-order accuracy in smooth regions while automatically reducing to lower-order, more stable behavior near discontinuities. The WENO framework was first introduced by Liu et al. 1994, building upon the earlier essentially non-oscillatory (ENO) schemes developed by Harten et al. 1987.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In practice, WENO schemes can be formulated either in a finite-volume or finite-difference framework. In this package, we adopt the finite-difference formulation, which is particularly well-suited for problems defined on structured grids due to its simplicity and computational efficiency. The time integration is based on a third order strong stability preserving Runge-Kutta (SSP-RK3) method.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The implementation of a finite-difference WENO scheme involves the following main steps:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Smoothness Indicators: For each candidate stencil, a smoothness indicator is computed. This indicator quantifies how smooth the approximation is within that stencil, with lower values indicating smoother regions.\nWeight Calculation: Nonlinear weights are computed based on the smoothness indicators. Stencils with lower smoothness indicators receive higher weights, allowing the scheme to adaptively favor smoother regions.\nReconstruction: The final high-order approximation is obtained by combining the candidate polynomials using the computed weights.\nFlux Evaluation: The reconstructed values are used to approximate the variable of interest at the cell interfaces, which are then used in the numerical flux calculations.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In FiniteDiffWENO5.jl, two forms of advection operators are currently supported:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Non-conservative Form mathbfv cdot nabla u, where the velocity field mathbfv and scalar field u are both defined at the same grid locations (collocated grid), and\nConservative Form nabla cdot (mathbfvu), where mathbfv is defined on cell faces and u at cell centers (staggered grid).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In both formulations, only the scalar field u is reconstructed at the cell interfaces using the WENO scheme.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The package currently implements the WENO-Z reconstruction developed by Borges et al. (2008). This variant introduces a modified computation of the nonlinear weights that improves accuracy near critical points—where the first derivative of the solution vanishes—while preserving the robust, non-oscillatory behavior of the classical WENO methods. Additional reconstruction variants may be included in future versions.","category":"page"},{"location":"#home","page":"Home","title":"FiniteDiffWENO5.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FiniteDiffWENO5.jl is a Julia package that implements fifth-order finite-difference weighted essentially non-oscillatory (WENO) schemes for solving hyperbolic partial differential equations (PDEs) in 1D, 2D and 3D on regular grids.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package currently focuses on the non-conservative form of the advection terms (mathbfv cdot nabla u) on a collocated grid, and the conservative form (nabla cdot (mathbfv u)) where the velocity field mathbfv and scalar field u are on a staggered grid with the advection velocity located on the sides of the cells.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core of the package is written in pure Julia, focusing on performance using CPUs, but GPU support is available using KernelAbstractions.jl and Chmy.jl via an extension.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FiniteDiffWENO5.jl is a registered package and may be installed directly with the following command in the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\n  pkg> add FiniteDiffWENO5\n  pkg> test FiniteDiffWENO5","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#FiniteDiffWENO5.WENOScheme-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API","title":"FiniteDiffWENO5.WENOScheme","text":"WENOScheme(c0::Array{T, N}; boundary::NTuple=ntuple(i -> 0, N*2), stag::Bool=false,  multithreading::Bool=false) where {T, N}\n\nStructure containing the Weighted Essentially Non-Oscillatory (WENO) scheme of order 5 constants and arrays for N-dimensional data of type T. The formulation is from Borges et al. 2008.\n\nArguments\n\nc0::Array{T, N}: The input field for which the WENO scheme is to be created. Only used to get the type and size.\nboundary::NTuple{2N, Int}: A tuple specifying the boundary conditions for each dimension (0: homogeneous Neumann, 1: homogeneous Dirichlet, 2: periodic). Default to homogeneous Neumann (0).\nstag::Bool: Whether the grid is staggered (velocities on cell faces) or not (velocities on cell centers). Default to false.\nmultithreading::Bool: Whether to use multithreading (only for 2D and 3D). Default to true.\n\nFields\n\nγ::NTuple{3, T}: Upwind and downwind constants.\nχ::NTuple{2, T}: Betas' constants.\nζ::NTuple{5, T}: Stencil weights.\nϵ::T: Tolerance, fixed to machine precision.\nstag::Bool: Whether the grid is staggered (velocities on cell faces) or not (velocities on cell centers).\nboundary::NTuple{N_boundary, Int}: Boundary conditions for each dimension (0: homogeneous Neumann, 1: homogeneous Dirichlet, 2: periodic). Default to homogeneous Neumann.\nlim_ZS::Bool: Whether to use the Zhang-Shu limiter.\nmultithreading::Bool: Whether to use multithreading (only for 2D and 3D).\nfl::NamedTuple: Fluxes in the left direction for each dimension.\nfr::NamedTuple: Fluxes in the right direction for each dimension.\ndu::Array{T, N}: Semi-discretisation of the advection term.\nut::Array{T, N}: Temporary array for intermediate calculations using Runge-Kutta.\n\n\n\n\n\n","category":"method"},{"location":"API/#FiniteDiffWENO5.WENO_step!-Union{Tuple{T}, Tuple{T, NamedTuple{(:x, :y), <:Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}}}, WENOScheme, Any, Any, Any}} where T<:(Matrix{<:Real})","page":"API","title":"FiniteDiffWENO5.WENO_step!","text":"WENO_step!(u::T,\n           v::NamedTuple{(:x, :y), <:Tuple{Vararg{AbstractArray{<:Real}, 2}}},\n           weno::WENOScheme,\n           Δt, Δx, Δy;\n           u_min = 0.0, u_max = 1.0) where {T <: AbstractArray{<:Real, 2}}\n\nAdvance the solution u by one time step using the 3rd-order SSP Runge-Kutta method with WENO5-Z as the spatial discretization in 2D.\n\nArguments\n\nu::T: Current solution array to be updated in place.\nv::NamedTuple{(:x, :y), <:Tuple{Vararg{AbstractArray{<:Real}, 2}}}: Velocity array (can be staggered or not based on weno.stag).\nweno::WENOScheme: WENO scheme structure containing necessary parameters and temporary arrays.\nΔt: Time step size.\nΔx: Spatial grid size in the x-direction.\nΔy: Spatial grid size in the y-direction.\nu_min: Minimum value of u for the Zhang-Shu positivity limiter.\nu_max: Maximum value of u for the Zhang-Shu positivity limiter.\n\nCitation: Borges et al. 2008: \"An improved weighted essentially non-oscillatory scheme for hyperbolic conservation laws\"           doi:10.1016/j.jcp.2007.11.038\n\n\n\n\n\n","category":"method"},{"location":"API/#FiniteDiffWENO5.WENO_step!-Union{Tuple{T}, Tuple{T, NamedTuple{(:x, :y, :z), <:Tuple{Array{<:Real}, Array{<:Real}, Array{<:Real}}}, WENOScheme, Vararg{Any, 4}}} where T<:(Array{<:Real, 3})","page":"API","title":"FiniteDiffWENO5.WENO_step!","text":"WENO_step!(u::T,\n           v::NamedTuple{(:x, :y, :z), <:Tuple{Vararg{Array{<:Real}, 3}}},\n           weno::WENOScheme,\n           Δt, Δx, Δy, Δz;\n           u_min = 0.0, u_max = 0.0) where T <: AbstractArray{<:Real, 3}\n\nAdvance the solution u by one time step using the 3rd-order SSP Runge-Kutta method with WENO5-Z as the spatial discretization in 3D.\n\nArguments\n\nu::T: Current solution array to be updated in place.\nv::NamedTuple{(:x, :y, :z), <:Tuple{Vararg{Array{<:Real}, 3}}}: Velocity fields in each direction, possibly staggered depending on weno.stag.\nweno::WENOScheme: WENO scheme structure containing necessary parameters and temporary arrays.\nΔt: Time step size.\nΔx: Spatial grid size in the x-direction.\nΔy: Spatial grid size in the y-direction.\nΔz: Spatial grid size in the z-direction.\nu_min: Minimum value of u for the Zhang-Shu positivity limiter.\nu_max: Maximum value of u for the Zhang-Shu positivity limiter.\n\nCitation: Borges et al. 2008: \"An improved weighted essentially non-oscillatory scheme for hyperbolic conservation laws\"           doi:10.1016/j.jcp.2007.11.038\n\n\n\n\n\n","category":"method"},{"location":"API/#FiniteDiffWENO5.WENO_step!-Union{Tuple{T}, Tuple{T, NamedTuple{(:x,), <:Tuple{var\"#s155\"} where var\"#s155\"<:(Vector{<:Real})}, WENOScheme, Any, Any}} where T<:(Vector{<:Real})","page":"API","title":"FiniteDiffWENO5.WENO_step!","text":"WENO_step!(u::T,\n           v::NamedTuple{(:x,), <:Tuple{<:Vector{<:Real}}},\n           weno::WENOScheme,\n           Δt, Δx;\n           u_min = 0.0, u_max = 0.0) where T <: AbstractVector{<:Real}\n\nAdvance the solution u by one time step using the 3rd-order SSP Runge-Kutta method with WENO5-Z as the spatial discretization in 1D.\n\nArguments\n\nu::T: Current solution array to be updated in place.\nv::NamedTuple{(:x,), <:Tuple{<:Vector{<:Real}}}: Velocity array (can be staggered or not based on weno.stag).\nweno::WENOScheme: WENO scheme structure containing necessary parameters and temporary arrays.\nΔt: Time step size.\nΔx: Spatial grid size.\nu_min: Minimum value of u for the Zhang-Shu positivity limiter.\nu_max: Maximum value of u for the Zhang-Shu positivity limiter.\n\nCitation: Borges et al. 2008: \"An improved weighted essentially non-oscillatory scheme for hyperbolic conservation laws\"           doi:10.1016/j.jcp.2007.11.038\n\n\n\n\n\n","category":"method"}]
}
